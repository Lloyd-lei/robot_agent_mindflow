# TTS 时间戳详细说明

## 🎯 概述

TTS 系统现在记录每个 chunk 生成和播放的详细时间戳，用于性能分析和问题诊断。

---

## ⏰ 时间戳类型

### 1. **perf_counter** (Python 高精度计时器)

```python
time.perf_counter()  # 单位：秒
```

**特点：**

- ✅ **高精度**：亚微秒级精度
- ✅ **单调递增**：不受系统时间调整影响
- ✅ **相对时间**：适合计算时间差
- ❌ **不是绝对时间**：无法转换为日期时间

**用途：**

- 测量代码执行时间
- 计算性能瓶颈
- 精确的时间差计算

### 2. **wall_clock** (系统墙钟时间)

```python
time.time()  # 单位：秒
```

**特点：**

- ✅ **绝对时间**：Unix 时间戳
- ✅ **可读性**：可转换为日期时间
- ⚠️ **可能倒退**：受系统时间调整影响
- ⚠️ **精度较低**：通常毫秒级

**用途：**

- 记录事件发生的实际时间
- 日志时间戳
- 跨系统时间同步

### 3. **datetime** (格式化时间戳)

```python
datetime.now().strftime("%H:%M:%S.%f")[:-3]  # HH:MM:SS.mmm
```

**特点：**

- ✅ **可读性强**：人类友好格式
- ✅ **毫秒精度**：`.mmm` 格式
- ✅ **日志友好**：适合打印输出

**示例：** `14:32:45.123`

---

## 📊 时间戳记录点

### 🔄 音频生成阶段

```
🔄 [生成 1/2] 尝试 1/3
   ⏰ 开始时间: 14:32:45.123
   📝 文本长度: 12 字符

✅ [Chunk 0] 生成成功
   ⏰ 完成时间: 14:32:47.456
   📊 生成统计:
      - TTS耗时: 2,333.0ms         ← TTS 引擎调用时间
      - 总耗时: 2,333.0ms           ← 包含重试等
      - 音频大小: 21,888 bytes
      - 字符/秒: 5.1               ← TTS 生成速度
```

**时间戳点：**

1. `ts_gen_start` - 开始生成（包括重试）
2. `ts_tts_start` - TTS 引擎调用开始
3. `ts_tts_end` - TTS 引擎调用结束
4. `ts_gen_end` - 生成完成

### 🔊 音频播放阶段

```
──────────────────────────────────────────────────────────────────────
🔊 [播放 1/2] 现在是02:30:15...
⏰ 开始时间: 14:32:48.123
   - perf_counter: 1234567.890123s
   - wall_clock:   1735012368.123456s

   ⏰ 音频加载: 14:32:48.123 -> 14:32:48.145 (22.0ms)
   📦 音频大小: 21,888 bytes
   ▶️  开始播放: 14:32:48.145
   ⏹️  播放结束: 14:32:49.678
   📊 播放统计:
      - 加载耗时: 22.0ms            ← pygame 加载音频
      - 播放耗时: 1533.0ms          ← 实际播放时间
      - 总计耗时: 1555.0ms
      - 轮询次数: 153               ← while 循环次数

   音频播放耗时: 1.533s

✅ [完成 1]
⏰ 结束时间: 14:32:50.478
   - perf_counter: 1234569.690123s
   - wall_clock:   1735012370.478456s
📊 耗时统计:
   - 音频播放: 1.555s              ← 加载 + 播放
   - 停顿时间: 0.800s (800ms)      ← 配置的停顿
   - 总计时长: 2.355s              ← 整个 chunk
──────────────────────────────────────────────────────────────────────
```

**时间戳点：**

1. `ts_start` - chunk 开始播放
2. `ts_load_start` - 音频加载开始
3. `ts_play_start` - 实际播放开始
4. `ts_play_end` - 播放结束
5. `ts_pause_start` - 停顿开始
6. `ts_end` - chunk 完成（停顿后）

---

## 🔍 性能分析指标

### 1. **TTS 生成速度**

```
字符/秒 = 文本长度 / TTS耗时
```

**参考值：**

- 优秀：> 10 字符/秒
- 正常：5-10 字符/秒
- 慢：< 5 字符/秒

### 2. **音频加载时间**

```
加载耗时 = ts_play_start - ts_load_start
```

**参考值：**

- 优秀：< 50ms
- 正常：50-200ms
- 慢：> 200ms

### 3. **播放实际耗时 vs 预期**

```
实际播放时间 = ts_play_end - ts_play_start
预期播放时间 ≈ 音频大小 / 比特率
```

**异常情况：**

- 实际 >> 预期：可能有性能问题
- 实际 << 预期：可能播放被中断

### 4. **轮询效率**

```
平均每次轮询 = 播放耗时 / 轮询次数
```

**参考值：**

- 理想：~10ms (sleep 0.01 秒)
- 正常：10-20ms
- 异常：> 50ms (可能 GIL 问题)

---

## 🐛 常见性能问题诊断

### 问题 1: TTS 生成慢

**症状：**

```
✅ [Chunk 0] 生成成功
   📊 生成统计:
      - TTS耗时: 5,000.0ms       ← 太慢！
      - 字符/秒: 2.4             ← 低于正常值
```

**可能原因：**

1. 网络延迟（Edge TTS 依赖网络）
2. TTS 服务器繁忙
3. 本地网络问题

**解决方案：**

- 检查网络连接
- 切换到更快的 TTS 服务（如本地 TTS）
- 增加超时时间和重试次数

---

### 问题 2: 音频加载慢

**症状：**

```
   📊 播放统计:
      - 加载耗时: 500.0ms        ← 太慢！
```

**可能原因：**

1. pygame 初始化问题
2. 音频文件过大
3. 磁盘 I/O 慢（如果写入临时文件）

**解决方案：**

- 预先初始化 pygame
- 减小音频比特率
- 使用内存流 (BytesIO)

---

### 问题 3: 播放时间异常

**症状：**

```
   📊 播放统计:
      - 播放耗时: 3000.0ms       ← 音频只有 1 秒
      - 轮询次数: 30             ← 每次 100ms？
```

**可能原因：**

1. **Python GIL 锁竞争**
2. CPU 占用过高
3. 系统睡眠不精确

**诊断方法：**

```python
平均轮询时间 = 3000ms / 30 = 100ms
# 正常应该是 10ms！
# 说明 sleep(0.01) 实际睡眠了 100ms
```

**解决方案：**

- 使用 threading.Event 替代 sleep
- 降低 CPU 使用率
- 使用更高精度的定时器

---

### 问题 4: perf_counter 和 wall_clock 差异大

**症状：**

```
⏰ 开始时间: 14:32:45.123
   - perf_counter: 123.456s
   - wall_clock:   1735012368.123s

⏰ 结束时间: 14:32:47.123
   - perf_counter: 125.456s      ← 差 2秒
   - wall_clock:   1735012372.123s ← 差 4秒！
```

**可能原因：**

1. **系统时间被调整**（NTP 同步）
2. 系统睡眠/唤醒
3. 虚拟机时钟漂移

**诊断：**

- 使用 perf_counter 差值判断真实耗时
- wall_clock 仅用于日志时间戳

---

## 📈 性能优化建议

### 1. **并发生成音频**

当前实现已支持，可调整并发数：

```python
tts_optimizer = TTSOptimizer(
    buffer_size=5  # 同时生成 5 个 chunk
)
```

### 2. **预加载音频**

在播放第 N 个 chunk 时，提前生成第 N+3 个 chunk

### 3. **使用更快的 TTS**

```python
# Edge TTS: 2-3秒/chunk
# OpenAI TTS-1: 1-2秒/chunk
# 本地 TTS: < 1秒/chunk
```

### 4. **减少停顿时间**

```python
# 默认 800ms，可以调整
tts_optimizer = TTSOptimizer(
    default_pause=500  # 500ms
)
```

---

## 🧪 测试命令

### 快速测试

```bash
python test_tts_timestamps.py
```

### 完整演示

```bash
python demo_hybrid.py
```

输入："现在几点了？"

---

## 📊 输出示例解读

### 完整的一个 Chunk 时间线

```
时间线：
│
├─ 14:32:45.123  🔄 开始生成 Chunk 0
│  └─ perf_counter: 1000.000s
│
├─ 14:32:45.130  📞 调用 TTS 引擎 (Edge TTS)
│
├─ 14:32:47.463  ✅ TTS 返回音频数据
│  └─ 耗时: 2,333ms
│
├─ 14:32:48.123  🔊 开始播放 Chunk 0
│  └─ perf_counter: 1002.333s
│
├─ 14:32:48.145  ▶️  pygame 开始播放
│  └─ 加载耗时: 22ms
│
├─ 14:32:49.678  ⏹️  播放完成
│  └─ 播放耗时: 1,533ms
│
├─ 14:32:49.678  ⏸️  开始停顿 (800ms)
│
├─ 14:32:50.478  ✅ Chunk 0 完成
│  └─ perf_counter: 1004.688s
│  └─ 总耗时: 2.355s
│
```

---

## 🔬 高级分析

### Python 解释器层面 vs 底层硬件

**判断方法：**

1. **Python 层面问题**

   - perf_counter 时间正常
   - 但 CPU 使用率低
   - GIL 锁竞争
   - 频繁上下文切换

2. **底层硬件问题**
   - perf_counter 和 wall_clock 都慢
   - CPU 使用率高
   - 磁盘 I/O 慢
   - 网络延迟

**工具：**

```bash
# 监控 CPU
top -pid $(pgrep -f demo_hybrid)

# 监控 I/O
iostat -x 1

# 监控网络
netstat -i
```

---

## 💡 总结

时间戳系统提供了以下能力：

1. ✅ **精确时间测量**：perf_counter 提供高精度
2. ✅ **可读日志**：datetime 格式友好
3. ✅ **性能分析**：详细的阶段耗时
4. ✅ **问题诊断**：轮询次数、异常检测
5. ✅ **优化指导**：瓶颈定位、改进方向

现在可以精确知道每个环节的耗时，快速定位性能问题！🎯
